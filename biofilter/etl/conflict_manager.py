import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Protection
from openpyxl.worksheet.datavalidation import DataValidation

from biofilter.utils.logger import Logger
from biofilter.db.models.entity_models import Entity, EntityName
from biofilter.db.models.omics_models import Gene
from biofilter.db.models.curation_models import (
    CurationConflict,
    ConflictStatus,
    ConflictResolution,
)  # noqa E501


# class ConflictManager(ConflictResolutionMixin):
class ConflictManager:
    def __init__(self, session, logger):
        self.session = session
        self.logger = Logger()

    def export_conflicts_to_excel(
        self, output_path="curation_conflicts_template.xlsx"
    ):  # noqa E501

        # Step 1: Query all conflicts
        conflicts = self.session.query(CurationConflict).all()

        if not conflicts:
            self.logger.log("No conflicts found to export.", "WARNING")
            return False

        wb = Workbook()
        ws = wb.active
        ws.title = "Conflicts"

        # Headers
        headers = [
            "id",
            "data_source_id",
            "data_source_name",
            "entity_type",
            "entity_id",
            "identifier",
            "existing_identifier",
            "status",
            "resolution",
            "description",
            "notes",
        ]
        ws.append(headers)

        for col in ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"]:
            ws[f"{col}1"].protection = Protection(locked=True)

        # Dropdown options
        status_values = ["pending", "resolved"]
        resolution_values = ["keep_both", "merge", "delete", ""]

        # Dropdowns
        status_dv = DataValidation(
            type="list", formula1=f'"{",".join(status_values)}"', allow_blank=False
        )  # noqa E501

        resolution_dv = DataValidation(
            type="list", formula1=f'"{",".join(resolution_values)}"', allow_blank=True
        )  # noqa E501

        # Apply data validation to the specific columns
        ws.add_data_validation(status_dv)
        ws.add_data_validation(resolution_dv)

        for idx, conflict in enumerate(conflicts, start=2):
            ws.append(
                [
                    conflict.id,  # A
                    conflict.data_source_id,  # B
                    conflict.data_source.name if conflict.data_source else "",  # C
                    conflict.entity_type,  # D
                    conflict.entity_id or "",  # E
                    conflict.identifier,  # F
                    conflict.existing_identifier,  # G
                    conflict.status.value if conflict.status else "",  # H
                    conflict.resolution.value if conflict.resolution else "",  # I
                    conflict.description or "",  # J
                    conflict.notes or "",  # K
                ]
            )

            # Data validation applied on status (H) and resolution (I)
            status_dv.add(ws[f"H{idx}"])
            resolution_dv.add(ws[f"I{idx}"])

            # Editable columns
            for col in ["H", "I", "K"]:
                ws[f"{col}{idx}"].protection = Protection(locked=False)

            # Protect columns against editing
            for col in ["A", "B", "C", "D", "E", "F", "G", "J"]:
                ws[f"{col}{idx}"].protection = Protection(locked=True)

        # Protect the sheet
        ws.protection.sheet = True
        ws.protection.enable()
        ws.protection.allow_format_columns = True
        ws.protection.allow_format_rows = True
        ws.protection.password = "biofilter"

        wb.save(output_path)

        msg = f"Excel files exported successfully to {output_path}"
        self.logger.log(msg, "INFO")

        return True

    def import_conflicts_from_excel(
        self, input_path="curation_conflicts_template.xlsx"
    ):  # noqa E501
        """
        Loads conflict decisions (status/resolution/notes) from an Excel file
        previously generated by `export_conflicts_to_excel()`.

        Only rows with real changes are updated.

        TODO: Add in the ETLLog when the Conflict is updated.
        """
        try:
            df = pd.read_excel(input_path)

            updated = 0
            for _, row in df.iterrows():
                conflict_id = row.get("id")
                if pd.isna(conflict_id):
                    continue

                conflict = self.session.query(CurationConflict).get(
                    int(conflict_id)
                )  # noqa E501
                if not conflict:
                    self.logger.log(
                        f"‚ö†Ô∏è Conflict ID {conflict_id} not found", "WARNING"
                    )  # noqa E501
                    continue

                # Parse status and resolution safely
                new_status = row.get("status")
                new_resolution = row.get("resolution")
                new_notes = row.get("notes")

                has_changes = False

                # Status
                if new_status and new_status != conflict.status.value:
                    conflict.status = ConflictStatus(new_status)
                    has_changes = True

                # Resolution
                if pd.notna(new_resolution) and new_resolution != "":
                    if (
                        conflict.resolution is None
                        or new_resolution != conflict.resolution.value
                    ):  # noqa E501
                        conflict.resolution = ConflictResolution(
                            new_resolution
                        )  # noqa E501
                        has_changes = True

                # Notes
                if pd.notna(new_notes) and new_notes != (conflict.notes or ""):
                    conflict.notes = new_notes
                    has_changes = True

                if has_changes:
                    updated += 1
                    self.logger.log(
                        f"üîÑ Updated conflict ID {conflict_id}", "DEBUG"
                    )  # noqa E501

            self.session.commit()
            self.logger.log(
                f"‚úÖ {updated} conflict(s) updated from Excel", "INFO"
            )  # noqa E501
            return updated

        except Exception as e:
            self.logger.log(
                f"‚ùå Failed to import conflicts from Excel: {e}", "ERROR"
            )  # noqa E501
            return 0

    def is_conflict_resolved(
        self, identifier_type: str, identifier: str
    ) -> bool:  # noqa E501
        return (
            self.session.query(CurationConflict)
            .filter_by(
                entity_type="gene",
                identifier_type=identifier_type,
                identifier_value=identifier,
                status=ConflictStatus.resolved,
            )
            .first()
            is not None
        )

    def apply_resolution(self, row):
        """
        Applies a curation resolution rule to a gene with previously
        resolved conflict.

        Parameters:
        - row: the current row being processed (pandas Series)
        """
        hgnc_id = row.get("hgnc_id")

        # Search for the resolved conflict associated with this gene
        conflict = (
            self.session.query(CurationConflict)
            .filter_by(
                entity_type="gene",
                identifier=hgnc_id,
                status=ConflictStatus.resolved
            )  # noqa: E501
            .first()
        )

        if not conflict:
            msg = f"No resolved conflict found for {hgnc_id}"
            self.logger.log(msg, "ERROR")
            return False

        resolution = conflict.resolution

        # DELETE BLOCK
        if resolution == ConflictResolution.delete:
            msg = f"üóëÔ∏è Applying DELETE resolution for Gene {hgnc_id}"
            self.logger.log(msg, "INFO")

            # üîí Mark the Entity as deacticated and conflict
            entity = (
                self.session.query(Entity).filter_by(id=conflict.entity_id).first()             # noqa: E501
            )  # noqa: E501
            if entity:
                entity.has_conflict = True
                entity.is_deactive = True
                msg = f"üîí Entity {entity.id} marked as inactive (delete)"
                self.logger.log(msg, "DEBUG")
            else:
                msg = f"‚ö†Ô∏è Entity ID {conflict.entity_id} not found"
                self.logger.log(msg, "WARNING")

            # ‚ùå Remove the Gene associated with the hgnc_id
            gene = self.session.query(Gene).filter_by(hgnc_id=hgnc_id).first()
            if gene:
                self.session.delete(gene)
                msg = f"üóëÔ∏è Gene {hgnc_id} deleted from database"
                self.logger.log(msg, "INFO")
            else:
                msg = f"‚ö†Ô∏è Gene {hgnc_id} not found during delete resolution"
                self.logger.log(msg, "WARNING")

            self.session.commit()

            # TODO: IMPORTANT DEVELOPMENT NOTE:
            # I desactivated the Entity and deleted the Gene if it exists,
            # but the aliases remained pointing to the deactivated entity!!!!!

            return False

        # MERGE BLOCK
        elif resolution == ConflictResolution.merge:
            # WHAT TO DO IN THIS STRATEGY:
            # 1. Deactivate the source entity
            # 2. Migrate the EntityNames from the source entity to the target entity                # noqa: E501
            # 3. Mark the source gene as "merged" (or merged_into)

            msg = f"üîÄ Applying MERGE resolution: {hgnc_id} ‚Üí {conflict.existing_identifier}"  # noqa: E501
            self.logger.log(msg, "INFO")

            # Load the target gene (the one that will remain in the system)
            target_gene = (
                self.session.query(Gene)
                .filter_by(hgnc_id=conflict.existing_identifier)
                .first()
            )
            if not target_gene:
                msg = f"‚ùå Target gene '{conflict.existing_identifier}' not found for merge"  # noqa: E501
                self.logger.log(msg, "ERROR")
                return False

            # üîí Mark the old Entity as inactive
            source_entity = (
                self.session.query(Entity)
                .filter_by(id=conflict.entity_id)
                .first()  # noqa: E501
            )
            if source_entity:
                source_entity.has_conflict = True
                source_entity.is_deactive = True
                msg = f"üîí Entity {source_entity.id} marked as inactive (merged)"  # noqa: E501
                self.logger.log(msg, "DEBUG")
            else:
                self.logger.log(
                    f"‚ö†Ô∏è Source entity ID {conflict.entity_id} not found",
                    "WARNING",  # noqa: E501
                )

            # Migration of EntityNames from the source entity to the target gene                    # noqa: E501
            # TODO: We are keeping the old code as is_primary, resulting in two names               # noqa: E501
            migrated = 0
            for name_obj in (
                self.session.query(EntityName)
                .filter_by(entity_id=source_entity.id)
                .all()
            ):
                exists = (
                    self.session.query(EntityName)
                    .filter_by(
                        entity_id=target_gene.entity_id, name=name_obj.name
                    )  # noqa: E501
                    .first()
                )
                if exists:
                    self.session.delete(name_obj)
                else:
                    name_obj.entity_id = target_gene.entity_id
                    migrated += 1

            msg = f"üîÅ Migrated {migrated} aliases to Entity {target_gene.entity_id}"  # noqa: E501
            self.logger.log(msg, "DEBUG")

            # Mark the source gene as MERGED
            # NOTE: We are not creating the source gene in the database, so we don't have it here.  # noqa: E501

            source_gene = (
                self.session.query(Gene).filter_by(hgnc_id=hgnc_id).first()
            )  # noqa: E501
            if source_gene:
                source_gene.hgnc_status = "merged"  # TODO: Create a new Field to hosting the Target Gene ID              # noqa: E501
                # source_gene.merged_into = target_gene.id
                msg = f"üìé Gene '{hgnc_id}' marked as merged into {target_gene.hgnc_id}"  # noqa: E501
                self.logger.log(msg, "DEBUG")

            self.session.commit()
            return False

        # KEEP_BOTH BLOCk
        elif resolution == ConflictResolution.keep_both:
            # WHAT TO DO IN THIS STRATEGY:
            # 1. Keep both genes in the system
            # 2. The dominant entity (item_exist) will be used for relationships and annotations    # noqa: E501

            msg = f"‚öñÔ∏è KEEP_BOTH resolution: {hgnc_id} and {conflict.existing_identifier}"  # noqa: E501
            self.logger.log(msg, "INFO")

            # Mark the Entity as having a conflict (but do not deactivate it!)
            entity = (
                self.session.query(Entity).filter_by(id=conflict.entity_id).first()
            )  # noqa: E501
            if entity:
                entity.has_conflict = True
                msg = f"üîí Entity {entity.id} marked with conflict (keep_both)"
                self.logger.log(msg, "DEBUG")
            else:
                msg = f"‚ö†Ô∏è Entity ID {conflict.entity_id} not found"
                self.logger.log(msg, "WARNING")

            # Log the conflict resolution
            msg = f"‚úîÔ∏è Both genes '{hgnc_id}' and '{conflict.item_exist}' kept ‚Äî shared ID resolution will favor '{conflict.item_exist}'"  # noqa: E501
            self.logger.log(msg, "INFO")

            # TODO: We nedd create a new Gene Here!!!

            self.session.commit()

            return False
